import {
  GetStaticPaths,
  GetStaticPathsContext,
  GetStaticPathsResult,
  GetStaticProps,
  GetStaticPropsContext,
  GetStaticPropsResult,
} from 'next';

export type GetStaticPropsContextWithData<D = unknown> = GetStaticPropsContext & {
  data?: D;
};

export async function defaultGetStaticProps(ctx: GetStaticPropsContextWithData) {
  return {
    props: ctx.data,
  };
}

export interface GetAllStaticDataParams<D = unknown, P = Record<string, unknown>> {
  /**
   * A field from the element type returned by `getData` to be used as the
   * `paths#params` value within the generated `getStaticPaths` function.
   */
  pathKey: keyof D;

  /**
   * Returns a list of data
   */
  getData(ctx: GetStaticPathsContext): Promise<D[]>;

  /**
   * By default, the `props` return property will equal to the data, and
   * `revalidate` is set to `1`.
   *
   * You can override this function as you like. It is exactly like a
   * `getStaticProps` function, but overloaded with `context.data` referencing
   * the data returned from `getData` with a matching path.
   */
  getStaticPropsWithData?: (context: GetStaticPropsContextWithData<D>) => Promise<GetStaticPropsResult<P>>;

  /**
   * Fallback value for `getStaticPaths`.
   */
  fallback?: GetStaticPathsResult['fallback'];
}

/**
 * Returns two factory functions which map to NextJS data-fetchers:
 *
 *  - `createGetStaticProps` -> `getStaticProps`
 *  - `createGetStaticPaths` -> `getStaticPaths`
 *
 * So, why do we do this? In some edge cases, the path data generated by
 * `getStaticProps` isn't enough to fetch the entity required to statically
 * populate the initial page props. We unblock this case using a shared
 * `getData` function that automatically reduces the relevant data for
 * `getStaticProps`.
 *
 * @usage
 *
 * ```ts
 * import { createStaticDataFactories } from 'lib/nextjs-static-data';
 *
 * export const { createGetStaticPaths, createGetStaticProps } = createStaticDataFactories<MyData>({
 *   pathKey: '...',
 *   getData: async ctx => ({ ...}),
 *   getStaticPropsWithData: async ctx => ({ ... }),
 * });
 *
 * export const getStaticPaths = createGetStaticPaths();
 * export const getStaticProps = createGetStaticProps();
 * ```
 */
export function createStaticDataFactories<D = unknown, P = Record<string, unknown>>({
  pathKey,
  getData,
  getStaticPropsWithData = defaultGetStaticProps as any,
  fallback = false,
}: GetAllStaticDataParams<D, P>) {
  const createGetStaticPaths: () => GetStaticPaths = () => async ctx => {
    const result = await getData(ctx);

    return {
      fallback,
      paths: result.map(element => ({
        params: { [pathKey]: element[pathKey] },
      })),
    } as any;
  };

  // @ts-expect-error
  const createGetStaticProps: () => GetStaticProps = () => async ctx => {
    const result = await getData(ctx);
    const _slug = ctx.params?.[pathKey as string];
    const slug = Array.isArray(_slug) ? _slug?.join('/') : _slug;
    const data = result.find(element => {
      const _innerSlug = element[pathKey];
      const innerSlug = Array.isArray(_innerSlug) ? _innerSlug?.join('/') : ctx.params?.slug;
      return innerSlug === slug;
    }) as D;

    return getStaticPropsWithData({ ...ctx, data });
  };

  return { createGetStaticPaths, createGetStaticProps };
}
